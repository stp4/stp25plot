---
title: "Grafiken"
output:
  pdf_document: default
  github_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(stpvers)
require(stp25plot)    # meine Funktionen
require(lattice)      # Lattice-Plots
require(RColorBrewer) # Farben
require(latticeExtra)
require(effects)      # Effekte
require(gridExtra)    # Plots agregieren

set.seed(2)
n <- 20 * 3 * 2
DF <- data.frame(
  n = runif(n, min = 1, max = 5),
  e = runif(n, min = 1, max = 5),
  o = runif(n, min = 1, max = 5),
  g = runif(n, min = 1, max = 5),
  a = cut(runif(n, min = 1, max = 5), 3, 1:3),
  treatment = gl(3, n / 3, labels = c("UG1", "UG2", "KG"))[sample.int(n)],
  sex = gl(2, n / 2, labels = c("male", "female"))
) 


DF <-
  Label(
    DF,
    sex="Geschlecht",
    n = "Neuroticism",
    e =  "Extraversion",
    o = "Openness",
    g = "Conscientiousness",
    a ="Agreeableness"
  )
```
 
## Funktionen


+ Theme for lattice-plots (Im Paket stp25output) set_lattice(), set_lattice_ggplot(), set_lattice_bw(), reset_lattice()
+ auto_plot Einzelne lattice plots analog wie die Funktion Tabelle()
+ Boxplot bwplot2()
+ profile_plot()
+ plot.bland_altman()
+ Hilfsfunktionen wrap_sentence(), stp25plot:::plot.efflist()


## Auto-Plot auto_plot()

Die Funktion klebt lattice- plots zu einer matrix zusammen.

Verwendung: auto_plot(formula, data) oder data %>% auto_plot(var_x, var_y, var_z) Die Funktion kann dabei Formel wie z.B.
$a+b+c\sim g$ 

$a[box]+b[bar]+c[dot]\sim g$

$log(a) +b +c \sim g$

$y \sim a+b+c$


https://www.zahlen-kern.de/editor/

```{r lattice-matrix-1, fig.height=5, fig.width=8}

DF %>% auto_plot(
  n,
  e[box],
  o[hist],
  g,
  a,
  treatment,
  by =  ~ sex,
  par.settings = set_lattice_bw(col = grey.colors(4, start = 0.4, end = 0.9))
)
```


```{r lattice-matrix-2, fig.height=2.5, fig.width=7}
reset_lattice()
auto_plot(treatment ~ n + e + sex, DF)

```

### set_lattice()

Initialisieren der Lattice - Optionen mit  set_lattice(). 
Im Hintergrund werden die  latticeExtra::ggplot2like.opts()
aufgerufen und die default Werte in opar und oopt gespeichert um sie mit reset_lattice() zurück seten zu können.

```
my_color <- function(n = 8)  RColorBrewer::brewer.pal(n, "Set2")
my_color_sex <-  function()   RColorBrewer::brewer.pal(8, "Set2")[c(4:3)]
my_color_dark <- function(n = 8)   RColorBrewer::brewer.pal(n, "Dark2")

```   
 
```{r pressure,  fig.height=3, fig.width=8, fig.cap='Plot mit grid.arrange - hier muss das Theme mit par.settings= set_lattice() uebergeben werden'}
reset_lattice()

p1<-barchart(xtabs(~treatment + sex + a,  DF), 
             auto.key=list(space="top", columns=3, 
                           cex=.7, between=.7 ),
             par.settings= set_lattice()) 
p2<-barchart(xtabs(~ treatment + sex + a,  DF), 
             auto.key=list(space="top", columns=3, 
                           cex=.7, between=.7 ),
             par.settings=set_lattice_bw()) 
p3<-barchart(xtabs(~ treatment + sex + a,  DF), 
             auto.key=list(space="top", columns=3, 
                           cex=.7, between=.7 ),
             par.settings=set_lattice_ggplot()) 

grid.arrange(p1, p2, p3, ncol=3)
```
  
 

Einbetten von set_lattice() über update()

```{r,  fig.height=4.5, fig.width=8, fig.cap='Plot mit grid.arrange und update'}
obj <-
  xyplot(
    Sepal.Length + Sepal.Width ~ Petal.Length + Petal.Width,
    iris, type = c("p", "r"),
    jitter.x = TRUE, jitter.y = TRUE, factor = 5,
    auto.key = list(
      cex.title = 1.2,
      title = "Expected Tau",
      text = c("30 ms", "80 ms", "130 ms", "180 ms"),
      space = "top" # lines = TRUE, rectangles = TRUE
    ))

obj <- update(obj, 
              legend = list(
                right =
                  list(fun = "draw.colorkey",
                       args = list(list(at = 0:100)))))

p1 <- update(obj, par.settings = custom.theme( ))
p2 <- update(obj, par.settings = set_lattice(theEconomist.theme()))
p3 <- update(obj, par.settings = set_lattice_bw(), axis = axis.grid)

grid.arrange(p1, p2, p3, ncol = 3)
```

      
###  bwplot2

Lattice bwplot mit groups. Ist eine erweiterung von lattice::bwplot. Die Funktion arbeitet mit panel.superpose.
  
 
```{r, results='asis', fig.cap='Boxplot mit bwplot2() und panel.superpose()', fig.height=5, fig.width=7}

p1 <- bwplot2(
  yield ~ site,
  data = barley, groups = year, main="bwplot2()", par.settings = set_lattice_bw(),
  auto.key = list(points = FALSE, rectangles = TRUE, space = "right")

)

p2 <-
  bwplot(
    yield ~ site,
    barley,groups = year, main="panel.superpose", par.settings = set_lattice_bw(),
    auto.key = list(points = FALSE, rectangles = TRUE, space = "right"),
    box.width = 1 / 4,
    panel = function(x, y, groups, subscripts, ...) {
      xx <- 
        as.numeric(x) + scale(as.numeric(groups), scale = FALSE)/(nlevels(groups)+1)
      panel.superpose(
        xx,  y,  ...,
        panel.groups = panel.bwplot,
        groups = groups,
        subscripts = subscripts
      )
    }
  )


grid.arrange(p1, p2)

```



```{r, fig.cap='Boxplot mit panel.bwplot() und  panel.superpose()',fig.height=2.5, fig.width=7}

set_lattice_bw(col=c("gray80", "gray90")) 

bwplot(yield ~ site, data = barley, groups=year,
       pch = "|", box.width = 1/3,
       auto.key = list(points = FALSE, rectangles = TRUE, space = "right"),
       panel = panel.superpose,
       panel.groups = function(x, y, ..., group.number) {
         panel.bwplot(x + (group.number-1.5)/3, y, ...)
         mean.values <- tapply(y, x, mean)
         panel.points(x + (group.number-1.5)/3, mean.values[x], pch=17)
}


)
```



```{r, results='asis', fig.cap='Mittelwerte mit einer Variante von panel.superpose()', fig.height=2.5, fig.width=7}

  bwplot(
    yield ~ site,
    barley, groups = year, main="panel.superpose", par.settings = set_lattice_bw(), 
    auto.key = list( points = FALSE, rectangles = TRUE, space = "right"),
    box.width = 1 / 4,
    panel = function(x, y, groups, subscripts, ...) {
      xx <- 
        as.numeric(x) + scale(as.numeric(groups), scale = FALSE) / 
        (nlevels(groups)+1)
      panel.superpose(
        xx,  y,  ..., panel.groups = panel.mean,
        groups = groups, subscripts = subscripts
      )
     panel.grid(h = -1, v = 0)
      # panel.stripplot(x, y, ..., jitter.data = TRUE,
      #                 groups = groups, subscripts = subscripts)
      # panel.superpose(x, y, ..., panel.groups = panel.average,
      #                 groups = groups, subscripts = subscripts)
      # panel.points(x, y, ..., panel.groups = panel.average,
      #              groups = groups, subscripts = subscripts)
    }
  )


 

```





### Forest

 forest_plot() gestohlen von survminer::ggforest()



```{r, include=FALSE}
require(survival)
colon<- Label(colon, sex="Geschlecht")

```

```{r forest-1, fig.height=4, fig.width=7}
fit1 <- lm(status ~ sex + rx + adhere,
           data = colon)
forest_plot(fit1)
 
```


```{r forest-2, fig.height=4, fig.width=7}

fit2 <- glm(status ~ sex + rx + adhere,
            data = colon, family = binomial())

forest_plot(fit2)

```

```{r forest-3, fig.height=4, fig.width=7}

fit3 <- coxph(Surv(time, status) ~ sex + rx + adhere,
              data = colon)

forest_plot(fit3, colon)


```

### profile_plot


```{r, include=FALSE}
set.seed(0815)
x = matrix(rnorm(50), ncol = 5)
colnames(x) = c("A", "B", "C", "D", "E")

## Create the profile plot. See the details in profile.plot.R for
## the details on the parameters
labels <- c(
  "aufregend - langweilig",
  "gut gemacht - schlecht gemacht",
  "glaubwürdig - unglaubwürdig",
  "spannend - eintönig",
  "verständlich - unverständlich",
"guter Action - schlechter Action",
  "sympathisch - unsympathisch",
  "talentiert - untalentiert",
  "modisch - unmodisch",
  "positive  - negative"
)


rownames(x) <- labels

```


```{r profil, fig.height=6, fig.width=7}
 
profile_plot(x,
             highlight.col = 2,
             legend.n.col = 5)
```

### Tortendiagramme


 
```{r, fig.height=3, fig.width=5}
print(torte(~treatment+sex, DF, init.angle=45, main="lattice"))

```


```{r, fig.height=3, fig.width=5}
 gtorte(~treatment+sex, DF, init.angle=45, main="ggplot")

```


```{r, fig.height=3, fig.width=5}
#  Geht nicht problemlos in Markdown
 tab <- as.data.frame(xtabs( ~ treatment + sex, DF))
# par(new = TRUE)
  stp25plot::piechart(~Freq|sex, tab, groups= treatment, auto.key=list(columns=3))
```


### MetComp_BAP

Tukey Mean Difference oder auch Bland Altman Metode

```{r, include=FALSE}
 
DF2<- data.frame(
  A=c(1, 5,10,20,50,40,50,60,70,80, 90,100,
      150,200,250,300,350,400,450,500,550,
      600,650,700,750,800,850,900, 950,1000),
  B=c(8,16,30,14,39,54,40,68,72,62,122, 80,
      181,259,275,380,320,434,479,587,626,
      648,738,766,793,851,871,957,1001,980),
  group= sample(gl(2, 15, labels = c("Control", "Treat")))
)

 

```



```{r ba-plot, fig.height=3, fig.width=7}

x<- MetComp_BAP(~A+B, DF2)
plot(x)

```

## cowplot

Zusammen mixen von unterschiedlichen Grafik-Typen.

The cowplot package is a simple add-on to ggplot.
https://wilkelab.org/cowplot/articles/index.html

```{r cowplot, fig.height=5, fig.width= 7}
library(ggplot2)
library(cowplot)
require(lattice)
p1<- ggplot(iris, aes(Sepal.Length, fill = Species)) +
  geom_density(alpha = 0.5) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme_minimal_hgrid(10)
p2<- densityplot(~Sepal.Length|Species , iris)

plot_grid(p1, p2,  rel_widths = c(1, 1.5)
           , labels = c('A', 'B'))
```




## Effectplot

### predictorEffect()
Von mir lang ignorierte Variante von Effect mit Formeln!

```{r, fig.height=3, fig.width=7}
mod <- lm(prestige ~ type*(education + income) + women, Prestige)
plot(predictorEffect("income", mod), main="", rug=FALSE)
plot(predictorEffects(mod, ~ education + women), main="", rug=FALSE)
plot(predictorEffects(mod, ~ women+ education),
     axes= list(x=list( women=list(lab="Anteil Frauen"),
                        education=list(lab="Bildung"))), main="", rug=FALSE)
```

### Modifizier plot.efflist


```{r, include=FALSE}
require(stpvers)
A = rnorm(100)
B = rnorm(100, 53, 10)
C = factor(rep(c("This", "That"), 50))
A <- A + log(B / 50) + as.numeric(C)
#log(B)
Logit <- function(x)
  car::logit(x, adjust = 0)

invLogit <- function(x)
  exp(x) / (1 + exp(x))



prop <- function(odds)
  odds / c(1 + odds)
odds <- function(p)
  p / (1 - p)

```

### allEffects ()

```{r, fig.height=2.5, fig.width=5}

ef <- allEffects(lm(A ~ B + C))
plot(ef,
     axes = list(
       x = list(
        B = list(
         transform = list(trans = log, inverse = exp),
         ticks = list(at = c(30, 50, 70)),
         lab = "Age, log-scale"),
       C = list(lab = "Treatment")
      ),
     y = list(lim= c(.0, 2.5),
              lab = "Vitamins"
              #  transform = list(link = Logit, inverse = invLogit),
              #  transform=list(trans=log, inverse=exp),
              #  type="rescale",
              #  ticks = list(at = c(.05, .25, .50, .75)),
              #   
       )),
     main = "")

```


Das ist hingegen obsolet!
 
``` 
plot.efflist <- stp25plot:::plot.efflist
ef <- allEffects(lm(A ~ B + C))
plot(ef, xlab = c("Foo", "Bar"), main="Modifiziert")

```




### Effectplot mit emmeans


```{r}
library(emmeans)
head(pigs)
pigs.lm1 <- lm(log(conc) ~ source + factor(percent), data = pigs)
ref_grid(pigs.lm1)

pigs.lm2 <- lm(log(conc) ~ source + percent, data = pigs)
ref_grid(pigs.lm2)


```

 

### emmeans default


```{r fit1-emean, fig.height=3, fig.width=4}
plot(emmeans(pigs.lm1,  
             ~ percent | source))
```

### emmeans ruecktransformiert

```{r fit1-emean-trans, fig.height=3, fig.width=4}
plot(emmeans(pigs.lm1,  
             ~ percent | source),
             xlab= "plasma leucine [mcg/ml]" , 
             type = "response")
```


```{r, fig.height=2.5, fig.width=4}
emmip(pigs.lm1, 
      source ~ percent)
```

```{r, fig.height=3, fig.width=4}
plot(emmeans(pigs.lm2,  
             ~ percent | source, 
             at = list(percent = c(10, 15, 20))
             )
     )
```


```{r, fig.height=2.5, fig.width=4}
emmip(
  ref_grid(pigs.lm2, cov.reduce = FALSE), 
  source ~ percent)
```

```{r, fig.height=2.5, fig.width=4}

emmip(ref_grid(pigs.lm2, 
               at= list(percent = c(10, 15, 20))), 
      source ~ percent,
      ylab= "plasma leucine [mcg/ml]" , 
      type = "response"
      )
```



### Klassiker mit Effect()

```{r, fig.height=2.5, fig.width=5}
set_lattice_ggplot()
plot(Effect(c("source", "percent"), 
            pigs.lm2,
            transformation=list(link=log, inverse=exp)),
     multiline=TRUE,
     key.args = list(space="right" ),
     main="", 
     ylab="plasma leucine [mcg/ml]") 

```



```{r, fig.height=2.5, fig.width=5}
 
emmip(ref_grid(pigs.lm2, 
               cov.reduce = FALSE, 
               transform = "response"), 
      source ~ percent  #,  CIs=TRUE
      ) + ggplot2::theme_classic()

```

```{r, fig.height=2.5, fig.width=5}

set_lattice_bw(col = c("coral3", "cyan4", "dodgerblue3"))
emmip(
  ref_grid(pigs.lm2,
           cov.reduce = FALSE,
           transform = "response"),
  source ~ percent,
  engine = "lattice"
)
```







```{r, fig.height=2.5, fig.width=5}

pigs.lm3 <- lm(log(conc) ~ source * percent, data = pigs)

plot(
  allEffects(pigs.lm3),
  main = "",
  multiline = TRUE,
  key.args = list(
    space = "right", columns = 1,
    border = FALSE,
    fontfamily = "serif",
    cex.title = .80,  cex = 0.75
  )
)

emmip(
  ref_grid(pigs.lm3, cov.reduce = TRUE), 
  source ~ percent)

emmip(
  ref_grid(pigs.lm3, cov.reduce = FALSE), 
  source ~ percent)

```







```{r, include=FALSE}

raw_data <-
  data.frame(
    subject_id = rep(1:6, 4),
    time = as.factor(rep(c("t0", "t1"), each = 12)),
    group = rep(rep(c("Control", "Treat"), each = 6), 2),
    value = c(2:7, 6:11, 3:8, 7:12)
  )


head(raw_data)

stripplot(
  value ~ time | group,
  groups = subject_id,
  data = raw_data,
  panel = function(x, y, ...) {
    panel.stripplot(x, y, 
                    type =  "b", 
                    col="blue",
                    lty = 2, ...)
       panel.average(x, y, fun = mean, lwd = 2, col = "gray80", ...)    # plot line connecting means
       mm<-mean(y) 
       panel.abline(h=mm, v=1.5, col="gray80")
       panel.text(x=1.5,y=mm, APA(wilcox.test(y~x)) )
       
   
   
  }
)

```




### transformation

library(effects)
 John Fox URL http://www.jstatsoft.org/v32/i01/

```{r, include=FALSE}
set.seed(2)

ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
edu <- cut(c(ctl, trt),3)
ctl2<- ctl + rnorm(10,0,.5)
trt2 <-trt + rnorm(10,1.2,.5)
group <- gl(2, 10, 40, labels = c("Ctl_gt", "Trt"))
serum <-round(rnorm(length(group)),2)
time <- factor(rep(1:2, each=20))


DF<- data.frame(id= factor(c(1:20, 1:20)),
                time,
                y = round(c(ctl, trt, ctl2, trt2) + serum +  as.numeric(group),2),
                y1 = round(c(ctl, trt, ctl2, trt2)*10,2),
                y2 = round(c(ctl, trt, ctl2, trt2)+2,2),
                group,
                edu= factor(c(edu,edu), labels=Cs(low, med, high)),
                serum )


```


```{r}
fit <- lm(y ~ group * time * serum, DF)
```



```{r, fig.height=5, fig.width= 5}
plot(effects::allEffects(fit)) 
```
 
 

```{r, fig.height=3, fig.width= 5}
APA2( ~ log(prestige) + income + type + education,
      data = Prestige,
      output = "text")
mod <- lm(log(prestige) ~ income:type + education, data = Prestige)

# does not work: effect("income:type", mod, transformation=list(link=log, inverse=exp))

plot(Effect(c("income", "type"), mod,
            transformation=list(link=log, inverse=exp)),
     main="", ylab="prestige") 

```
 
 
 
 
```{r, fig.cap='Effect patial.residuals',fig.height=3, fig.width= 5}
set_lattice_bw()
plot(
  Effect(c("time", "group"), fit,
         partial.residuals = TRUE),
  main = FALSE,
  lty = 0,
  partial.residuals = list(pch = 16,
                           col = gray.colors(nrow(DF))[order(DF$serum)])
)
```
 

 


 

### GOF-Plots

library(car)

```{r, fig.cap='residualPlots', fig.height=5, fig.width= 5}
car::residualPlots(fit) 
```
 
```{r, fig.cap='marginalModelPlots',  fig.height=3, fig.width= 5}
car::marginalModelPlots(fit) 
```
  
```{r, fig.cap='avPlots',  fig.height=5, fig.width= 5}
car::avPlots(fit) 
```
 






 
### library(visreg)

 Patrick Breheny and Woodrow Burchett 
 URL: https://cran.r-project.org/web/packages/visreg/vignettes/quick-start.html


```{r, fig.cap='visreg', fig.height=3, fig.width= 7, warning=FALSE }
par(mfrow=c(1,3))
visreg::visreg(fit)

```
 
### library(stats) termplot


```{r, fig.cap='termplot',fig.height=3, fig.width= 7, warning=FALSE}
par(mfrow=c(1,3))
stats::termplot(fit, 
                se = TRUE, 
                resid = TRUE, 
                plot=TRUE, ask=FALSE)


```

library(rockchalk)
Paul E. Johnson
URL https://github.com/pauljohn32/rockchalk

Hier gibt es keine Updates mehr???

```
rockchalk::plotSlopes(fit, 
                      plotx = "group", 
                      interval = "confidence")
```



```
rockchalk::plotSlopes(fit, 
                      plotx = "group", 
                      modx = "time", 
                      interval = "confidence")
```





```{r}
raw_data <-
  data.frame(
    subject_id = rep(1:6, 4),
    time = as.factor(rep(c("t0", "t1"), each = 12)),
    group = rep(rep(c("Control", "Treat"), each = 6), 2),
    value = c(2:7, 6:11, 3:8, 7:12)
  )
head(raw_data)

stripplot(
  value ~ time | group,
  groups = subject_id,
  data = raw_data,
  panel = function(x, y, ...) {
    panel.stripplot(x,
                    y,
                    type =  "b",
                    col = "blue",
                    lty = 2,
                    ...)
    panel.average(x,
                  y,
                  fun = mean,
                  lwd = 2,
                  col = "gray80",
                  ...)    # plot line connecting means
    mm <- mean(y)
    panel.abline(h = mm, v = 1.5, col = "gray80")
    panel.text(x = 1.5, y = mm, APA(wilcox.test(y ~ x)))
  
  }
)

```


### ECDF-Plot

```{r}
 data(Chem97, package = "mlmRev")

 ecdfplot(~gcsescore | factor(score), data = Chem97,
     groups = gender, 
     auto.key = list(columns = 2), 
     subset = gcsescore > 0, 
     xlab = "Average GCSE Score")
```



data(singer, package = "lattice")
 

## Interessante Grafik Beispiele


```{r, fig.height=4, fig.width= 7}
 require(latticeExtra)
 segplot(factor(1:10) ~ rnorm(10) + rnorm(10), level = runif(10))
 
 data(USCancerRates)
 
 segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
         data = subset(USCancerRates, state == "Washington"))
 
 segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
         data = subset(USCancerRates, state == "Washington"),
         draw.bands = FALSE, 
         centers = rate.male)
 
 segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
         data = subset(USCancerRates, state == "Washington"),
         level = rate.female,
         col.regions = terrain.colors)
 
 segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
         data = subset(USCancerRates, state == "Washington"),
         draw.bands = FALSE, 
         centers = rate.male, 
         segments.fun = panel.arrows, 
         ends = "both", 
         angle = 90, 
         length = 1, 
         unit = "mm")
 
 segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male, 
         data = subset(USCancerRates, state ==  "Washington"), 
         draw.bands = FALSE, centers = rate.male)
```





## Links


https://ggobi.github.io/ggally/index.html


http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/78-perfect-scatter-plots-with-correlation-and-marginal-histograms/

 ggpubr

http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/78-perfect-scatter-plots-with-correlation-and-marginal-histograms/
